/*******************************************************************************
 * Copyright (c) 2020 Association Cénotélie (cenotelie.fr)
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation, either version 3
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General
 * Public License along with this program.
 * If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/

//! Module for generating parser code in Java

use std::fs::File;
use std::io::{self, Write};
use std::path::PathBuf;

use crate::errors::Error;
use crate::grammars::{Grammar, TerminalSet, PREFIX_GENERATED_TERMINAL, PREFIX_GENERATED_VARIABLE};
use crate::output::get_parser_bin_name_java;
use crate::output::helper::{to_lower_camel_case, to_upper_camel_case, to_upper_case};
use crate::{Modifier, ParsingMethod, CRATE_VERSION};

/// Generates code for the specified file
pub fn write(
    path: Option<&String>,
    file_name: String,
    grammar: &Grammar,
    expected: &TerminalSet,
    method: ParsingMethod,
    nmespace: &str,
    modifier: Modifier,
) -> Result<(), Error> {
    let mut final_path = PathBuf::new();
    if let Some(path) = path {
        final_path.push(path);
    }
    final_path.push(file_name);
    let file = File::create(final_path)?;
    let mut writer = io::BufWriter::new(file);

    let name = to_upper_camel_case(&grammar.name);
    let modifier = match modifier {
        Modifier::Public => "public ",
        Modifier::Internal => "",
    };
    let (parser_type, automaton_type) = if method.is_rnglr() {
        ("RNGLRParser", "RNGLRAutomaton")
    } else {
        ("LRkParser", "LRkAutomaton")
    };
    let bin_name = get_parser_bin_name_java(grammar);

    writeln!(writer, "/*")?;
    writeln!(writer, " * WARNING: this file has been generated by")?;
    writeln!(writer, " * Hime Parser Generator {CRATE_VERSION}")?;
    writeln!(writer, " */")?;
    writeln!(writer)?;

    writeln!(writer, "package {nmespace};")?;
    writeln!(writer)?;
    writeln!(writer, "import fr.cenotelie.hime.redist.ASTNode;")?;
    writeln!(writer, "import fr.cenotelie.hime.redist.ParseResult;")?;
    writeln!(writer, "import fr.cenotelie.hime.redist.SemanticAction;")?;
    writeln!(writer, "import fr.cenotelie.hime.redist.SemanticBody;")?;
    writeln!(writer, "import fr.cenotelie.hime.redist.Symbol;")?;
    writeln!(writer, "import fr.cenotelie.hime.redist.parsers.{automaton_type};")?;
    writeln!(writer, "import fr.cenotelie.hime.redist.parsers.{parser_type};")?;
    writeln!(writer)?;
    writeln!(writer, "import java.util.Map;")?;
    writeln!(writer)?;

    writeln!(writer, "/**")?;
    writeln!(writer, " * Represents a parser")?;
    writeln!(writer, " */")?;
    writeln!(writer, "{}class {}Parser extends {} {{", modifier, &name, parser_type)?;

    writeln!(writer, "    /**")?;
    writeln!(writer, "     * The automaton for this parser")?;
    writeln!(writer, "     */")?;
    writeln!(
        writer,
        "    private static final {} COMMON_AUTOMATON = {}.find({}Parser.class, \"{}\");",
        automaton_type, automaton_type, &name, bin_name
    )?;

    write_code_symbols(&mut writer, grammar)?;
    write_code_variables(&mut writer, grammar)?;
    write_code_virtuals(&mut writer, grammar)?;
    write_code_actions(&mut writer, grammar)?;
    write_code_constructors(&mut writer, grammar, method)?;
    write_code_visitor(&mut writer, grammar, expected)?;

    writeln!(writer, "}}")?;
    Ok(())
}

/// Generates the code for the symbols
fn write_code_symbols(writer: &mut dyn Write, grammar: &Grammar) -> Result<(), Error> {
    writeln!(writer, "    /**")?;
    writeln!(
        writer,
        "     * Contains the constant IDs for the variables and virtuals in this parser"
    )?;
    writeln!(writer, "     */")?;
    writeln!(writer, "    public static class ID {{")?;
    for variable in grammar
        .variables
        .iter()
        .filter(|v| !v.name.starts_with(PREFIX_GENERATED_VARIABLE))
    {
        writeln!(writer, "        /**")?;
        writeln!(writer, "         * The unique identifier for variable {}", &variable.name)?;
        writeln!(writer, "         */")?;
        writeln!(
            writer,
            "        public static final int VARIABLE_{} = 0x{:04X};",
            to_upper_case(&variable.name),
            variable.id
        )?;
    }
    for symbol in &grammar.virtuals {
        writeln!(writer, "        /**")?;
        writeln!(writer, "         * The unique identifier for virtual {}", &symbol.name)?;
        writeln!(writer, "         */")?;
        writeln!(
            writer,
            "        public static final int VIRTUAL_{} = 0x{:04X};",
            to_upper_case(&symbol.name),
            symbol.id
        )?;
    }
    writeln!(writer, "    }}")?;
    Ok(())
}

/// Generates the code for the variables
fn write_code_variables(writer: &mut dyn Write, grammar: &Grammar) -> Result<(), Error> {
    writeln!(writer, "    /**")?;
    writeln!(writer, "     * The collection of variables matched by this parser")?;
    writeln!(writer, "     *")?;
    writeln!(writer, "     * The variables are in an order consistent with the automaton,")?;
    writeln!(
        writer,
        "     * so that variable indices in the automaton can be used to retrieve the variables in this table"
    )?;
    writeln!(writer, "     */")?;
    writeln!(writer, "    private static final Symbol[] variables = {{")?;
    for (index, variable) in grammar.variables.iter().enumerate() {
        if index > 0 {
            writeln!(writer, ", ")?;
        }
        write!(writer, "        ")?;
        write!(writer, "new Symbol(0x{:04X}, \"{}\")", variable.id, &variable.name)?;
    }
    writeln!(writer, " }};")?;
    Ok(())
}

/// Generates the code for the virtual symbols
fn write_code_virtuals(writer: &mut dyn Write, grammar: &Grammar) -> Result<(), Error> {
    writeln!(writer, "    /**")?;
    writeln!(writer, "     * The collection of virtuals matched by this parser")?;
    writeln!(writer, "     *")?;
    writeln!(writer, "     * The virtuals are in an order consistent with the automaton,")?;
    writeln!(
        writer,
        "     * so that virtual indices in the automaton can be used to retrieve the virtuals in this table"
    )?;
    writeln!(writer, "     */")?;
    writeln!(writer, "    private static final Symbol[] virtuals = {{")?;
    for (index, symbol) in grammar.virtuals.iter().enumerate() {
        if index > 0 {
            writeln!(writer, ", ")?;
        }
        write!(writer, "        ")?;
        write!(writer, "new Symbol(0x{:04X}, \"{}\")", symbol.id, &symbol.name)?;
    }
    writeln!(writer, " }};")?;
    Ok(())
}

/// Generates the code for the semantic actions
fn write_code_actions(writer: &mut dyn Write, grammar: &Grammar) -> Result<(), Error> {
    if grammar.actions.is_empty() {
        return Ok(());
    }
    writeln!(writer, "    /**")?;
    writeln!(writer, "     * Represents a set of semantic actions in this parser")?;
    writeln!(writer, "     */")?;
    writeln!(writer, "    public static interface IActions {{")?;
    for action in &grammar.actions {
        writeln!(writer, "        /**")?;
        writeln!(writer, "         * The {} semantic action", &action.name)?;
        writeln!(writer, "         */")?;
        writeln!(
            writer,
            "        public void {}(Symbol head, SemanticBody body);",
            to_lower_camel_case(&action.name)
        )?;
    }
    writeln!(writer)?;
    writeln!(writer, "    }}")?;

    writeln!(writer, "    private static class NoActions implements IActions {{")?;
    for action in &grammar.actions {
        writeln!(
            writer,
            "        public void {}(Symbol head, SemanticBody body) {{}}",
            to_lower_camel_case(&action.name)
        )?;
    }
    writeln!(writer)?;
    writeln!(writer, "    }}")?;

    writeln!(writer, "    /**")?;
    writeln!(writer, "     * Represents a set of empty semantic actions (do nothing)")?;
    writeln!(writer, "     */")?;
    writeln!(writer, "    private static final NoActions noActions = new NoActions();")?;

    writeln!(writer, "    /**")?;
    writeln!(
        writer,
        "     * Gets the set of semantic actions in the form a table consistent with the automaton"
    )?;
    writeln!(writer, "     *")?;
    writeln!(writer, "     * @param input A set of semantic actions")?;
    writeln!(writer, "     * @return A table of semantic actions")?;
    writeln!(writer, "     */")?;
    writeln!(
        writer,
        "    private static SemanticAction[] getUserActions(final IActions input) {{"
    )?;
    writeln!(
        writer,
        "        SemanticAction[] result = new SemanticAction[{}];",
        grammar.actions.len()
    )?;
    for (index, action) in grammar.actions.iter().enumerate() {
        writeln!(writer, "        result[{}] = new SemanticAction() {{ @Override public void execute(Symbol head, SemanticBody body) {{ input.{}(head, body); }} }};", index, to_lower_camel_case(&action.name))?;
    }
    writeln!(writer, "        return result;")?;
    writeln!(writer, "    }}")?;

    writeln!(writer, "    /**")?;
    writeln!(
        writer,
        "     * Gets the set of semantic actions in the form a table consistent with the automaton"
    )?;
    writeln!(writer, "     *")?;
    writeln!(writer, "     * @param input A set of semantic actions")?;
    writeln!(writer, "     * @return A table of semantic actions")?;
    writeln!(writer, "     */")?;
    writeln!(
        writer,
        "    private static SemanticAction[] getUserActions(Map<String, SemanticAction> input)"
    )?;
    writeln!(writer, "    {{")?;
    writeln!(
        writer,
        "        SemanticAction[] result = new SemanticAction[{}];",
        grammar.actions.len()
    )?;
    for (index, action) in grammar.actions.iter().enumerate() {
        writeln!(writer, "        result[{}] = input.get(\"{}\");", index, &action.name)?;
    }
    writeln!(writer, "        return result;")?;
    writeln!(writer, "    }}")?;
    Ok(())
}

/// Generates the code for the constructors
fn write_code_constructors(writer: &mut dyn Write, grammar: &Grammar, method: ParsingMethod) -> Result<(), Error> {
    let name = to_upper_camel_case(&grammar.name);
    let exception = if method.is_rnglr() {
        "throws InitializationException "
    } else {
        ""
    };
    writeln!(writer, "    /**")?;
    writeln!(writer, "     * Initializes a new instance of the parser")?;
    writeln!(writer, "     *")?;
    writeln!(writer, "     * @param lexer The input lexer")?;
    writeln!(writer, "     */")?;
    writeln!(writer, "    public {}Parser({}Lexer lexer) {}{{", &name, &name, exception)?;
    if grammar.actions.is_empty() {
        writeln!(writer, "        super(COMMON_AUTOMATON, variables, virtuals, null, lexer);")?;
    } else {
        writeln!(
            writer,
            "        super(COMMON_AUTOMATON, variables, virtuals, getUserActions(noActions), lexer);"
        )?;
        writeln!(writer, "    }}")?;

        writeln!(writer, "    /**")?;
        writeln!(writer, "     * Initializes a new instance of the parser")?;
        writeln!(writer, "     *")?;
        writeln!(writer, "     * @param lexer The input lexer")?;
        writeln!(writer, "     * @param actions The set of semantic actions")?;
        writeln!(writer, "     */")?;
        writeln!(
            writer,
            "    public {}Parser({}Lexer lexer, IActions actions) {}{{",
            &name, &name, exception
        )?;
        writeln!(
            writer,
            "        super(COMMON_AUTOMATON, variables, virtuals, getUserActions(actions), lexer);"
        )?;
        writeln!(writer, "    }}")?;

        writeln!(writer, "    /**")?;
        writeln!(writer, "     * Initializes a new instance of the parser")?;
        writeln!(writer, "     *")?;
        writeln!(writer, "     * @param lexer The input lexer")?;
        writeln!(writer, "     * @param actions The set of semantic actions")?;
        writeln!(writer, "     */")?;
        writeln!(
            writer,
            "    public {}Parser({}Lexer lexer, Map<String, SemanticAction> actions) {}{{",
            &name, &name, exception
        )?;
        writeln!(
            writer,
            "        super(COMMON_AUTOMATON, variables, virtuals, getUserActions(actions), lexer);"
        )?;
    }
    writeln!(writer, "    }}")?;
    Ok(())
}

/// Generates the visitor for the parse result
#[allow(clippy::too_many_lines)]
fn write_code_visitor(writer: &mut dyn Write, grammar: &Grammar, expected: &TerminalSet) -> Result<(), Error> {
    writeln!(writer)?;
    writeln!(writer, "    /*")?;
    writeln!(writer, "     * Visitor interface")?;
    writeln!(writer, "     */")?;
    writeln!(writer, "    public static interface IVisitor {{")?;
    for terminal_ref in &expected.content {
        let Some(terminal) = grammar.get_terminal(terminal_ref.sid()) else {
            continue;
        };
        if terminal.name.starts_with(PREFIX_GENERATED_TERMINAL) {
            continue;
        }
        writeln!(
            writer,
            "        public void onTerminal{}(ASTNode node);",
            to_upper_camel_case(&terminal.name)
        )?;
    }
    for variable in &grammar.variables {
        if variable.name.starts_with(PREFIX_GENERATED_VARIABLE) {
            continue;
        }
        writeln!(
            writer,
            "        public void onVariable{}(ASTNode node);",
            to_upper_camel_case(&variable.name)
        )?;
    }
    for symbol in &grammar.virtuals {
        writeln!(
            writer,
            "        public void onVirtual{}(ASTNode node);",
            to_upper_camel_case(&symbol.name)
        )?;
    }
    writeln!(writer, "    }}")?;
    writeln!(writer)?;
    writeln!(writer, "    /*")?;
    writeln!(writer, "     * Walk the AST of a result using a visitor")?;
    writeln!(writer, "     *")?;
    writeln!(writer, "     * @param result  The parse result")?;
    writeln!(writer, "     * @param visitor The visitor to use")?;
    writeln!(writer, "     */")?;
    writeln!(
        writer,
        "    public static void visit(ParseResult result, IVisitor visitor) {{"
    )?;
    writeln!(writer, "        visitASTNode(result.getRoot(), visitor);")?;
    writeln!(writer, "    }}")?;
    writeln!(writer)?;
    writeln!(writer, "    /*")?;
    writeln!(writer, "     * Walk the sub-AST from the specified node using a visitor")?;
    writeln!(writer, "     *")?;
    writeln!(writer, "     * @param node    The AST node to start from")?;
    writeln!(writer, "     * @param visitor The visitor to use")?;
    writeln!(writer, "     */")?;
    writeln!(
        writer,
        "    public static void visitASTNode(ASTNode node, IVisitor visitor) {{"
    )?;
    writeln!(writer, "        for (ASTNode child : node.getChildren())")?;
    writeln!(writer, "            visitASTNode(child, visitor);")?;
    writeln!(writer, "        switch(node.getSymbol().getID()) {{")?;
    for terminal_ref in &expected.content {
        let Some(terminal) = grammar.get_terminal(terminal_ref.sid()) else {
            continue;
        };
        if terminal.name.starts_with(PREFIX_GENERATED_TERMINAL) {
            continue;
        }
        writeln!(
            writer,
            "            case 0x{:04X}: visitor.onTerminal{}(node); break;",
            terminal.id,
            to_upper_camel_case(&terminal.name)
        )?;
    }
    for variable in &grammar.variables {
        if variable.name.starts_with(PREFIX_GENERATED_VARIABLE) {
            continue;
        }
        writeln!(
            writer,
            "            case 0x{:04X}: visitor.onVariable{}(node); break;",
            variable.id,
            to_upper_camel_case(&variable.name)
        )?;
    }
    for symbol in &grammar.virtuals {
        writeln!(
            writer,
            "            case 0x{:04X}: visitor.onVirtual{}(node); break;",
            symbol.id,
            to_upper_camel_case(&symbol.name)
        )?;
    }
    writeln!(writer, "        }}")?;
    writeln!(writer, "    }}")?;
    Ok(())
}
